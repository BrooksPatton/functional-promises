(function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId]){return installedModules[moduleId].exports}var module=installedModules[moduleId]={i:moduleId,l:false,exports:{}};modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.l=true;return module.exports}__webpack_require__.m=modules;__webpack_require__.c=installedModules;__webpack_require__.d=function(exports,name,getter){if(!__webpack_require__.o(exports,name)){Object.defineProperty(exports,name,{configurable:false,enumerable:true,get:getter})}};__webpack_require__.n=function(module){var getter=module&&module.__esModule?function getDefault(){return module["default"]}:function getModuleExports(){return module};__webpack_require__.d(getter,"a",getter);return getter};__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)};__webpack_require__.p="";return __webpack_require__(__webpack_require__.s=0)})([function(module,exports,__webpack_require__){(function(process){const{FunctionalError:FunctionalError}=__webpack_require__(1);const{isFunction:isFunction,flatten:flatten}=__webpack_require__(2);const{chain:chain,chainEnd:chainEnd}=__webpack_require__(4);const FP=FunctionalPromises;FP.default=FP;Object.assign(FP.prototype,__webpack_require__(5),__webpack_require__(6),__webpack_require__(7),__webpack_require__(8));function FunctionalPromises(resolveRejectCB){if(!(this instanceof FunctionalPromises)){return new FunctionalPromises(resolveRejectCB)}if(arguments.length!==1)throw new Error("FunctionalPromises constructor only accepts 1 callback argument");this._FP={errors:{limit:0,count:0},promise:new Promise(resolveRejectCB),concurrencyLimit:4}}FP.all=FP.prototype.all;FP.thenIf=FP.prototype._thenIf;FP.delay=(msec=>FP.resolve().delay(msec));FP.silent=(limit=>FP.resolve().silent(limit));FP.chain=chain;FP.prototype.chainEnd=chainEnd;FP.reject=FP.prototype.reject;FP.prototype.addStep=function addStep(name,args){if(this.steps)this.steps.push([name,this,args]);return this};FP.prototype.concurrency=function concurrency(limit=Infinity){if(this.steps)return this.addStep("concurrency",[...arguments]);this._FP.concurrencyLimit=limit;return this};FP.prototype.quiet=function quiet(errorLimit=Infinity){if(this.steps)return this.addStep("quiet",[...arguments]);this._FP.errors={count:0,limit:errorLimit};return this};FP.prototype.silent=FP.prototype.quiet;FP.prototype.get=function get(...keyNames){if(this.steps)return this.addStep("get",[...arguments]);keyNames=flatten(keyNames);return this.then(obj=>{if(typeof obj==="object"){if(keyNames.length===1)return obj[keyNames[0]];return keyNames.reduce((extracted,key)=>{extracted[key]=obj[key];return extracted},{})}return obj})};FP.prototype.set=function set(keyName,value){if(this.steps)return this.addStep("set",[...arguments]);return this.then(obj=>{if(typeof obj==="object")obj[keyName]=value;return obj})};FP.prototype.catch=function(fn){if(this.steps)return this.addStep("catch",[...arguments]);if(arguments.length===2)return this.catchIf(...arguments);if(!isFunction(fn))throw new FunctionalError("Invalid fn argument for `.catch(fn)`. Must be a function. Currently: "+typeof fn);return FP.resolve(this._FP.promise.catch(err=>fn(err)))};FP.prototype.catchIf=function catchIf(condition,fn){if(this.steps)return this.addStep("catchIf",[...arguments]);if(!isFunction(fn))throw new FunctionalError("Invalid fn argument for `.catchIf(condition, fn)`. Must be a function. Currently: "+typeof fn);return FP.resolve(this._FP.promise.catch(err=>{if(condition&&err instanceof condition)return fn(err);throw err}))};FP.prototype.then=function then(fn){if(this.steps)return this.addStep("then",[...arguments]);if(!isFunction(fn))throw new FunctionalError("Invalid fn argument for `.then(fn)`. Must be a function. Currently: "+typeof fn);return FP.resolve(this._FP.promise.then(fn))};FP.prototype.tap=function tap(fn){if(this.steps)return this.addStep("tap",[...arguments]);if(!isFunction(fn))throw new FunctionalError("Invalid fn argument for `.tap(fn)`. Must be a function. Currently: "+typeof fn);return FP.resolve(this._FP.promise.then(value=>fn(value)?value:value))};FP.resolve=FP.prototype.resolve=function resolve(value){return new FP((resolve,reject)=>{if(value&&isFunction(value.then))return value.then(resolve).catch(reject);resolve(value)})};FP.promisify=function promisify(cb){return(...args)=>new FP((yah,nah)=>cb.call(this,...args,(err,res)=>err?nah(err):yah(res)))};FP.promisifyAll=function promisifyAll(obj){if(!obj||!Object.getPrototypeOf(obj)){throw new Error("Invalid Argument obj in promisifyAll(obj)")}return Object.getOwnPropertyNames(obj).filter(key=>typeof obj[key]==="function").reduce((obj,fnName)=>{if(!/Sync/.test(fnName)&&!obj[`${fnName}Async`])obj[`${fnName}Async`]=FP.promisify(obj[`${fnName}`]);return obj},obj)};FP.unpack=function unpack(){let resolve,reject,promise=new FP((yah,nah)=>{resolve=yah;reject=nah});return{promise:promise,resolve:resolve,reject:reject}};module.exports=FunctionalPromises;if(process&&process.on){process.on("unhandledRejection",e=>console.error("FPromises: FATAL ERROR: unhandledRejection",e))}}).call(exports,__webpack_require__(3))},function(module,exports){class FunctionalError extends Error{constructor(msg,options){if(typeof msg==="object"){options=msg;if(msg.message)msg=msg.message}super(msg);if(typeof options==="object"){Object.getOwnPropertyNames(options).forEach(key=>{this[key]=options[key]})}this.name=this.constructor.name;Error.captureStackTrace(this,this.constructor)}}class FunctionalUserError extends FunctionalError{}class FPUnexpectedError extends FunctionalError{}class FPInputError extends FunctionalError{}class FPSoftError extends FunctionalError{}class FPTimeout extends FunctionalError{}module.exports={FunctionalError:FunctionalError,FunctionalUserError:FunctionalUserError,FPUnexpectedError:FPUnexpectedError,FPInputError:FPInputError,FPSoftError:FPSoftError,FPTimeout:FPTimeout}},function(module,exports){const utils=module.exports={isPromiseLike(p){return p&&typeof p.then==="function"},isFunction(fn){return typeof fn==="function"},isEnumerable(list){return list&&Array.isArray(list)||typeof list[Symbol.iterator]==="function"},flatten(arr){if(!Array.isArray(arr))throw new Error("Method `flatten` requires valid array parameter");return arr.reduce((results,item)=>results.concat(Array.isArray(item)?utils.flatten(item):[item]),[])}}},function(module,exports){var process=module.exports={};var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}(function(){try{if(typeof setTimeout==="function"){cachedSetTimeout=setTimeout}else{cachedSetTimeout=defaultSetTimout}}catch(e){cachedSetTimeout=defaultSetTimout}try{if(typeof clearTimeout==="function"){cachedClearTimeout=clearTimeout}else{cachedClearTimeout=defaultClearTimeout}}catch(e){cachedClearTimeout=defaultClearTimeout}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){return setTimeout(fun,0)}if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0)}try{return cachedSetTimeout(fun,0)}catch(e){try{return cachedSetTimeout.call(null,fun,0)}catch(e){return cachedSetTimeout.call(this,fun,0)}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){return clearTimeout(marker)}if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker)}try{return cachedClearTimeout(marker)}catch(e){try{return cachedClearTimeout.call(null,marker)}catch(e){return cachedClearTimeout.call(this,marker)}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue)}else{queueIndex=-1}if(queue.length){drainQueue()}}function drainQueue(){if(draining){return}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run()}}queueIndex=-1;len=queue.length}currentQueue=null;draining=false;runClearTimeout(timeout)}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i]}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue)}};function Item(fun,array){this.fun=fun;this.array=array}Item.prototype.run=function(){this.fun.apply(null,this.array)};process.title="browser";process.browser=true;process.env={};process.argv=[];process.version="";process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[]};process.binding=function(name){throw new Error("process.binding is not supported")};process.cwd=function(){return"/"};process.chdir=function(dir){throw new Error("process.chdir is not supported")};process.umask=function(){return 0}},function(module,exports,__webpack_require__){const{FPInputError:FPInputError}=__webpack_require__(1);module.exports={chain:chain,chainEnd:chainEnd};function chain(){const FP=__webpack_require__(0);const promise=FP.resolve();promise.steps=[];return promise}function chainEnd(){const FP=__webpack_require__(0);return input=>{if(!this.steps||this.steps.length<=0)throw new FPInputError("No steps defined between .chain() & .chainEnd()");let stepCount=0;let{promise:promise,resolve:resolve,reject:reject}=FP.unpack();while(stepCount<this.steps.length){const[fnName,,args]=this.steps[stepCount];promise=promise[fnName](...args);stepCount++}resolve(input);return promise}}},function(module,exports,__webpack_require__){const{isEnumerable:isEnumerable}=__webpack_require__(2);const{FPInputError:FPInputError,FunctionalError:FunctionalError}=__webpack_require__(1);module.exports={map:map,find:find,findIndex:findIndex,filter:filter,reduce:reduce};function find(callback){return _find.call(this,callback).then(({item:item})=>item)}function findIndex(callback){return _find.call(this,callback).then(({index:index})=>index)}function _find(iterable,callback){const FP=__webpack_require__(0);if(this.steps)return this.addStep("_find",[...arguments]);if(typeof iterable==="function"){callback=iterable;iterable=this._FP.promise}return FP.resolve(iterable).filter(callback).then(results=>results[0]!=undefined?{item:results[0],index:results.indexOf(results[0])}:{item:undefined,index:-1})}function filter(iterable,callback){if(this.steps)return this.addStep("filter",[...arguments]);if(typeof iterable==="function"){callback=iterable;iterable=this._FP.promise}return reduce(iterable,(acc,item)=>Promise.resolve(callback(item)).then(x=>x?acc.concat([item]):acc),[])}function reduce(iterable,reducer,initVal){const FP=__webpack_require__(0);if(this.steps)return this.addStep("reduce",[...arguments]);if(typeof iterable==="function"){initVal=reducer;reducer=iterable;iterable=this._FP?this._FP.promise:this}else iterable=FP.resolve(iterable,this);return new FP((resolve,reject)=>{return iterable.then(iterable=>{const iterator=iterable[Symbol.iterator]();let i=0;const next=total=>{const current=iterator.next();if(current.done)return resolve(total);Promise.all([total,current.value]).then(([total,item])=>next(reducer(total,item,i++))).catch(reject)};next(initVal)})})}function map(args,fn,options){const FP=__webpack_require__(0);if(this.steps)return this.addStep("map",[...arguments]);if(arguments.length===1&&this&&this._FP){fn=args;args=this&&this._FP&&this._FP.promise}let resolvedOrRejected=false;const threadLimit=Math.max(1,Math.min(this&&this._FP&&this._FP.concurrencyLimit||1,4));const innerValues=this&&this._FP&&this._FP.promise?this._FP.promise:Promise.resolve(args);let initialThread=0;let errors=[];let count=0;const results=[];const threadPool=new Set;const threadPoolFull=()=>threadPool.size>=threadLimit;const isDone=()=>errors.length>this._FP.errors.limit||count>=args.length||resolvedOrRejected;const setResult=index=>value=>{threadPool.delete(index);results[index]=value;return value};return FP.resolve(new Promise((resolve,reject)=>{const resolveIt=x=>{if(resolvedOrRejected){return null}else{resolvedOrRejected=true}resolve(x)};const rejectIt=x=>{if(resolvedOrRejected){return null}else{resolvedOrRejected=true}reject(x)};innerValues.then(items=>{args=[...items];if(!isEnumerable(items))return reject(new FPInputError("Invalid input data passed into FP.map()"));const complete=()=>{let action=null;if(errors.length>this._FP.errors.limit)action=rejectIt;if(isDone())action=resolveIt;if(action)return Promise.all(results).then(data=>action(results))?true:true;return false};const checkAndRun=val=>{if(resolvedOrRejected)return;if(!complete()&&!results[count])runItem(count);return val};const runItem=c=>{if(resolvedOrRejected){return null}else{count++}if(threadPoolFull())return setTimeout(()=>runItem(c),0);if(results[c])return results[c];threadPool.add(c);results[c]=Promise.resolve(args[c]).then(val=>fn(val,c,args)).then(val=>setResult(c)(val)).then(checkAndRun).catch(err=>{this._FP.errors.count++;errors.push(err);if(errors.length>this._FP.errors.limit){const fpErr=errors.length===1?err:new FunctionalError(`Error Limit ${this._FP.errors.limit} Exceeded.\n              idx=${c} errCnt=${this._FP.errors.count}`,{errors:errors,results:results,ctx:this});Promise.resolve(setResult(c)(err)).then(()=>rejectIt(fpErr))}else{return Promise.resolve().then(()=>setResult(c)(err)).then(checkAndRun)}});return results[c]};while(initialThread<threadLimit&&initialThread<args.length)runItem(initialThread++)})}))}},function(module,exports,__webpack_require__){const{FPInputError:FPInputError}=__webpack_require__(1);module.exports={listen(obj,...eventNames){if(typeof eventNames==="string")eventNames=[eventNames];if(!obj[obj.addEventListener?"addEventListener":"on"])throw new FPInputError("Valid EventEmitter required.");const handler=this.chainEnd();this._FP.destroy=(()=>this._FP.destroyHandles.map(fn=>fn()||true).filter(v=>v).length);this._FP.destroyHandles=eventNames.map(eventName=>{obj[obj.addEventListener?"addEventListener":"on"](eventName,handler);return()=>obj[obj.removeEventListener?"removeEventListener":"off"](eventName,handler)});return this}}},function(module,exports,__webpack_require__){const{isPromiseLike:isPromiseLike}=__webpack_require__(2);module.exports={thenIf:thenIf,tapIf:tapIf,_thenIf:_thenIf};function thenIf(cond,ifTrue,ifFalse){if(this.steps)return this.addStep("thenIf",[...arguments]);if(arguments.length===1){ifTrue=cond;cond=(x=>x)}if(isPromiseLike(this)){return this.then(value=>_thenIf(cond,ifTrue,ifFalse)(value))}return _thenIf(cond,ifTrue,ifFalse)}function tapIf(cond,ifTrue,ifFalse){if(this.steps)return this.addStep("tapIf",[...arguments]);if(arguments.length===1){ifTrue=cond;cond=(x=>x)}if(isPromiseLike(this)){return this.then(value=>_thenIf(cond,ifTrue,ifFalse,true)(value))}return _thenIf(cond,ifTrue,ifFalse,true)}function _thenIf(cond=(x=>x),ifTrue=(x=>x),ifFalse=(()=>null),returnValue=false){const FP=__webpack_require__(0);return value=>FP.resolve(cond(value)).then(ans=>ans?ifTrue(value):ifFalse(value)).then(v=>returnValue?value:v)}},function(module,exports,__webpack_require__){const{FPInputError:FPInputError}=__webpack_require__(1);module.exports={all:all,reject:reject,delay:delay,_delay:_delay};function all(promises){const FP=__webpack_require__(0);return FP.resolve(Array.isArray(promises)?Promise.all(promises):promiseAllObject(promises))}function promiseAllObject(obj){const keys=Object.getOwnPropertyNames(obj);const values=keys.map(key=>obj[key]);return Promise.all(values).then(results=>results.reduce((obj,val,index)=>{var _Object$assign;const key=keys[index];return Object.assign((_Object$assign={},_Object$assign[key]=val,_Object$assign),obj)},{}))}function reject(err){if(err instanceof Error){if(this)this._error=err;return Promise.reject(err)}throw new Error(`Reject only accepts a new instance of Error!`)}function _delay(msec){const FP=__webpack_require__(0);if(!Number.isInteger(msec))throw new FPInputError("FP.delay(millisec) requires a numeric arg.");return value=>new FP(resolve=>{setTimeout(()=>resolve(value),msec)})}function delay(msec){const FP=__webpack_require__(0);if(this.steps)return this.addStep("delay",[...arguments]);return this&&this._FP?FP.resolve(this.then(_delay(msec))):_delay(msec)()}}]);